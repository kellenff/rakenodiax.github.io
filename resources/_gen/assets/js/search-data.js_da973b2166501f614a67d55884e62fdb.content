(function(){const pages=[{"idx":0,"href":"/categories/","title":"Categories","content":""},{"idx":1,"href":"/posts/dicers-rust-on-lambda/","title":"Dice.rs: Rust on Lambda","content":" Rust support on AWS Lambda was recently released, which seems like as good an opportunity as any to share some code and the solutions to challenges I encountered along the way â˜º. I\u0026rsquo;ve decided to create a little diceware service, and the lambda-runtime crate provides a great API to make this a breeze.\nSetting up the library We\u0026rsquo;re going to generate a basic crate:\n$ cargo new dicers --lib \u0026amp;\u0026amp; cd dicers Created library `dicers` project  You should see a structure similar to this:\n$ ls -a ./\t.git/\tCargo.toml ../\t.gitignore\tsrc/  Write the core data structure I\u0026rsquo;m going to expose the phrase generator as a dictionary which implements an Iterator, from which the user can take however many words needed for the phrase. Iterators also provide a nice way to seed and add to the dictionary. The Rust standard library includes traits for both of these features: FromIterator and Extend; we\u0026rsquo;ll write two quick tests to describe this behavior:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #[cfg(test)]mod tests{usesuper::*;#[test]fn dictionary_implements_from_iterator(){letseed=||vec![\u0026#34;foo\u0026#34;.to_string(),\u0026#34;bar\u0026#34;.to_string()].into_iter();letdictionary=Dictionary::from_iter(seed());assert_eq!(dictionary.words,HashSet::from_iter(seed()));}#[test]fn dictionary_implements_extend(){letaddition=||vec![\u0026#34;foo\u0026#34;.to_string(),\u0026#34;bar\u0026#34;.to_string()].into_iter();letmutdictionary=Dictionary::default();dictionary.extend(addition());assert_eq!(dictionary.words,HashSet::from_iter(addition().map(|s|s.to_string())));}}   cargo test prompts us to create a Dictionary struct and import HashSet. We can derive some basic traits for Dictionary while we\u0026rsquo;re at it:\n1 2 3 4 5 6  usestd::collections::HashSet;#[derive(Debug, Default, Clone, PartialEq)]pubstruct Dictionary{words: HashSet\u0026lt;String\u0026gt;}   Now cargo test leads us to import the appropriate traits so they can be used:\n1 2  usestd::collections::HashSet;usestd::iter::{Extend,FromIterator};   Implementing Extend and FromIterator is incredibly easy, as the underlying HashSet implements them:\n9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  impl\u0026lt;S\u0026gt;FromIterator\u0026lt;S\u0026gt;forDictionarywhereS: ToString,{fn from_iter\u0026lt;I: IntoIterator\u0026lt;Item=S\u0026gt;\u0026gt;(iter: I)-\u0026gt; Dictionary{letwords=HashSet::from_iter(iter.into_iter().map(|s|s.to_string()));Dictionary{words}}}impl\u0026lt;S\u0026gt;Extend\u0026lt;S\u0026gt;forDictionarywhereS: ToString,{fn extend\u0026lt;I: IntoIterator\u0026lt;Item=S\u0026gt;\u0026gt;(\u0026amp;mutself,iter: I){self.words.extend(iter.into_iter().map(|s|s.to_string()));}}   And now the tests pass, yay!\nrunning 2 tests test tests::dictionary_implements_from_iterator ... ok test tests::dictionary_implements_extend ... ok test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out  Iterating over generated words Now we\u0026rsquo;ll implement Iterator for Dictionary. This iterator will return a random word each time next is called. First things first, we\u0026rsquo;ll write a test that exercises this behavior:\n56 57 58 59 60 61 62 63 64 65  #[test]fn dictionary_can_be_iterated_over(){letword=\u0026#34;foo\u0026#34;;letdictionary=Dictionary::from_iter(vec![word].into_iter());letgenerated=dictionary.iter().next();assert_eq!(generated,Some(word));}   Each time the dictionary is iterated over, a separate RNG will be instantiated. A DictionaryIterator struct contains a borrow of the Dictionary.words, and the RNG:\n1  userand::prelude::*;   30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  implDictionary{pubfn iter(\u0026amp;self)-\u0026gt; DictionaryIterator{DictionaryIterator::new(\u0026amp;self.words)}}pubstruct DictionaryIterator\u0026lt;\u0026#39;a\u0026gt;{words: \u0026amp;\u0026#39;aHashSet\u0026lt;String\u0026gt;,rng: ThreadRng,}impl\u0026lt;\u0026#39;a\u0026gt;DictionaryIterator\u0026lt;\u0026#39;a\u0026gt;{fn new(words: \u0026amp;\u0026#39;aHashSet\u0026lt;String\u0026gt;)-\u0026gt; DictionaryIterator\u0026lt;\u0026#39;a\u0026gt;{letrng=thread_rng();DictionaryIterator{words,rng}}}impl\u0026lt;\u0026#39;a\u0026gt;IteratorforDictionaryIterator\u0026lt;\u0026#39;a\u0026gt;{type Item=\u0026amp;\u0026#39;astr;fn next(\u0026amp;mutself)-\u0026gt; Option\u0026lt;Self::Item\u0026gt;{letword_count=self.words.len();letindex=self.rng.gen_range(0,word_count);self.words.iter().nth(index).map(|s|s.as_str())}}  \nDon\u0026rsquo;t forget to add rand as a dependency to Cargo.toml:\n[dependencies] rand = \u0026quot;0.6.1\u0026quot;  Using an iterator allows the use of take to generate arbitrary numbers of words:\nletfour=dictionary.iter().take(4); Populating the dictionary In actual use, the Dictionary needs to be seeded with a given set of words. We\u0026rsquo;ll store this in a text file, with each line being a word in the dictionary, and add support to read any string in this format and create a Dictionary from it:\n13 14 15 16 17 18  implDictionary{pubfn read_str(input: \u0026amp;str)-\u0026gt; Dictionary{// `String.lines` implements `Iterator`, so we can use it directly with `FromIterator` Dictionary::from_iter(input.lines())}}   Building against AWS Lambda The lambda-runtime crate is pretty simple to use. We define a handler function which takes a serde deserializable struct and context, returning either a serde serializable struct or an error. Let\u0026rsquo;s start by adding the necessary dependencies to Cargo.toml:\nlambda_runtime = \u0026quot;0.1.0\u0026quot; serde_derive = \u0026quot;1.0.80\u0026quot;  We\u0026rsquo;ll implement the API in a separate module: create src/api.rs and declare the module in src/lib.rs:\n5 6  mod api;pubuseself::api::handler;   We\u0026rsquo;ll start with the request and response structs, in src/api.rs:\n1 2 3 4 5 6 7 8 9 10 11 12  useserde_derive::{Deserialize,Serialize};#[derive(Debug, Deserialize)]pubstruct GenerateEvent{word_count: u8,separator: char,}#[derive(Debug, Serialize)]pubstruct GenerateResponse{phrase: String,}   The business logic is simple enough that we can just implement it directly in the handler function used by Lambda.\n1  usesuper::Dictionary;   17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  pubfn handler(event: GenerateEvent,_ctx: Context)-\u0026gt; Result\u0026lt;GenerateResponse,HandlerError\u0026gt;{matchevent{GenerateEvent{word_count,separator: Some(separator),}=\u0026gt;{letseed=include_str!(\u0026#34;../resources/dictionary.txt\u0026#34;);letdictionary=Dictionary::read_str(\u0026amp;seed);letwords: Vec\u0026lt;\u0026amp;str\u0026gt;=dictionary.iter().take(word_countasusize).collect();letphrase=words.as_slice().join(\u0026amp;separator.to_string());Ok(GenerateResponse{phrase})}GenerateEvent{word_count,separator: None,}=\u0026gt;{letseed=include_str!(\u0026#34;../resources/dictionary.txt\u0026#34;);letdictionary=Dictionary::read_str(\u0026amp;seed);// Iterators of type `\u0026amp;str` can be joined into one `String` with `collect` letphrase: String =dictionary.iter().take(word_countasusize).collect();Ok(GenerateResponse{phrase})}}}  \nThis implementation can definitely be cleaned up; there\u0026rsquo;s the repeated logic of reading the dictionary file, along with unwrap, which means that the function could panic at runtime. We can clean this up by using the lazy_static crate:\n3 4 5 6 7 8 9 10 11  uselazy_static::lazy_static;useserde_derive::{Deserialize,Serialize};lazy_static!{staticrefDICTIONARY: Dictionary={letseed=include_str!(\u0026#34;../resources/dictionary.txt\u0026#34;);Dictionary::read_str(\u0026amp;seed)}}   The dictionary will now be instantiated the first time it\u0026rsquo;s used. Let\u0026rsquo;s use the dictionary in our handler:\n22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  pubfn handler(event: GenerateEvent,_ctx: Context)-\u0026gt; Result\u0026lt;GenerateResponse,HandlerError\u0026gt;{matchevent{GenerateEvent{word_count,separator: Some(separator),}=\u0026gt;{letwords: Vec\u0026lt;\u0026amp;str\u0026gt;=DICTIONARY.iter().take(word_countasusize).collect();letphrase=words.as_slice().join(\u0026amp;separator.to_string());Ok(GenerateResponse{phrase})}GenerateEvent{word_count,separator: None,}=\u0026gt;{// Iterators of type `\u0026amp;str` can be joined into one `String` with `collect` letphrase: String =DICTIONARY.iter().take(word_countasusize).collect();Ok(GenerateResponse{phrase})}}}   Write a main function The lambda_runtime crate provides a macro for exposing a handler function to Lambda. The complete main.rs file:\n1 2 3 4 5 6 7 8  usedicers::handler;uselambda_runtime::lambda;fn main()-\u0026gt; Result\u0026lt;(),Box\u0026lt;dynstd::error::Error\u0026gt;\u0026gt;{lambda!(handler);Ok(())}   Deploy to AWS Lambda The crate must be built for the x86_64-unknown-linux-musl target. If you are MacOS, the following steps will allow for cross compilation:\n# Add the target via rustup $ rustup target add x86_64-unknown-linux-musl # install the homebrew cross-compilation binaries $ brew install filosottile/musl-cross/musl-cross # cargo can\u0026#39;t find the default binary name, so we use a symlink to the one it is expecting $ ln -s /usr/local/bin/x86_64-linux-musl-gcc /usr/local/bin/musl-gcc And add the following configuration file, located at .cargo/config:\n[build] target = \u0026quot;x86_64-unknown-linux-musl\u0026quot; [target.x86_64-unknown-linux-musl] linker = \u0026quot;x86_64-linux-musl-gcc\u0026quot;  This will tell cargo to build for the appropriate target, and use the linker we just installed. Now we can build and publish the Lambda function using the AWS CLI:\n# Build with optimizations $ cargo build --release # Copy the binary as a bootstrap file $ cp ./target/x86_64-unknown-linux-musl/release/dicers ./bootstrap # Compress into a lambda archive and remove the intermediary bootstrap file $ zip lambda.zip bootstrap \u0026amp;\u0026amp; rm bootstrap # Replace the `role` argument with the Role ARN from the AWS IAM console. The user must be granted the `lambda:CreateFunction` permission and the role allowed `XRay:PutTraceSegments`: $ aws lambda create-function --function-name dicers \\ --handler doesnt.matter \\ --zip-file fileb://./lambda.zip \\ --runtime provided \\ --role arn:aws:iam::XXXXXXXXXXX:role/my-role \\ --environment Variables={RUST_BACKTRACE=1} \\ --tracing-config Mode=Active And now we can use a test invocation to ensure it\u0026rsquo;s up and running:\n$ aws lambda invoke --function-name dicers \\ --payload \u0026#39;{\u0026#34;word_count\u0026#34;: 5, \u0026#34;separator\u0026#34;:\u0026#34;-\u0026#34;}\u0026#39; \\ output.json { \u0026#34;StatusCode\u0026#34;: 200, \u0026#34;ExecutedVersion\u0026#34;: \u0026#34;$LATEST\u0026#34; } $ cat output.json {\u0026#34;phrase\u0026#34;:\u0026#34;heading-reimburse-preformed-pledge-appliance\u0026#34;} And that should be it! The final source can be found here.\nI\u0026rsquo;d love to get feedback on this post: discuss on Reddit, open a GitLab Issue or send me a tweet.\n"},{"idx":2,"href":"/","title":"Kellen Frodelius-Fujimoto","content":""},{"idx":3,"href":"/posts/","title":"Posts","content":""},{"idx":4,"href":"/tags/","title":"Tags","content":""},{"idx":5,"href":"/tags/aws/","title":"aws","content":""},{"idx":6,"href":"/tags/lambda/","title":"lambda","content":""},{"idx":7,"href":"/categories/programming/","title":"programming","content":""},{"idx":8,"href":"/tags/rust/","title":"rust","content":""},{"idx":9,"href":"/tags/walkthrough/","title":"walkthrough","content":""},{"idx":10,"href":"/about/","title":"About","content":"I am a developer, photographer, and learner living in NRW, Germany with my wife and cat. Currently seeking opportunities in full-stack and backend development, local and remote: please get in touch.\nCorrections, suggestions, and questions welcome here.\n"},{"idx":11,"href":"/about/gallery/","title":"Gallery","content":""},{"idx":12,"href":"/about/gallery/noel-and-bella/","title":"NoÃ«l and Bella","content":""},{"idx":13,"href":"/projects/","title":"Projects","content":" rust-client A command line http client designed for speed and ergonomics, written in Rust.\ndice.rs A diceware library with support for AWS Lambda. Subject of this blog post.\n"}];window.bookSearch={pages:pages,idx:lunr(function(){this.ref("idx");this.field("title");this.field("content");pages.forEach(this.add,this);}),}})();